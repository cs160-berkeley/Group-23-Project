let Pins = require("pins");let remotePins = require("pins");let PLOTTER = require('plotter');let titleStyle = new Style({ font: "20px", color: "white" });import {    VerticalScroller,    VerticalScrollbar,    TopScrollerShadow,    BottomScrollerShadow} from 'scroller';let whiteSkin = new Skin ({fill: 'white'});let graySkin = new Skin ({fill: 'gray'});let blackSkin = new Skin ({fill: 'black'});let darkGraySkin = new Skin({ fill: "#202020" });let whiteHeaderStyle = new Style({ font: "30px", color: "white" });let whiteMedStyle = new Style({ font: "20px", color: "white" });let whiteSmallStyle = new Style({ font: "10px", color: "white" });let rightdots = new Texture("images/dot-menu-right.png");let rightmenuDots = new Skin({      width: 150, height: 50,      texture: rightdots,      fill: "white",      aspect: "fit"});
let labelStyle = new Style({ color: '#47476B', font: '30px Helvetica bold' });let GraphContainer = Container.template($ => ({ 	left: 0, right: 0, top: 0, height: 150, }));let GraphLabel1 = Line.template($ => ({ 	left: 10, bottom: 5,	skin: new Skin({ fill: '#B3FFFFFF',}), 	contents: [		Label($, { style: labelStyle, string: 'Pet Temperature: ' }),		Label($, { 			style: labelStyle, string: '--', 			behavior: Behavior({				onCreate: function(content, data) {					this.name = data.name;				},				onReceiveReading: function(content, reading, name) {					//update the value string					trace(name);					if (this.name == name ) {			        	content.string = reading.toFixed(2);			 		}				},			})		}),	]}));let GraphCanvas1 = PLOTTER.Plotter.template($ => ({ 	left: 5, right: 5, top: 5,	behavior: PLOTTER.PlotterBehavior({		onTimeChanged: function(content) {			remotePins.invoke("/temp/read", data => {				application.distribute("gotReading", data);			});		},	})}));let GraphLabel2 = Line.template($ => ({ 	left: 10, bottom: 5, 	skin: new Skin({ fill: '#B3FFFFFF',}), 	contents: [		Label($, { style: labelStyle, string: 'Heart Rate:' }),		Label($, { 			style: labelStyle, string: '--', 			behavior: Behavior({				onCreate: function(content, data) {					this.name = data.name;				},				onReceiveReading: function(content, reading, name) {					//update the value string					if (this.name == name ) {			        	content.string = reading.toFixed(2);			 		}				},			})		}),	]}));let GraphCanvas2 = PLOTTER.Plotter.template($ => ({ 	left: 5, right: 5, top: 5,  	behavior: PLOTTER.PlotterBehavior({		onTimeChanged: function(content) {			remotePins.invoke("/weight/read", data => {				application.distribute("gotReading", data);			});		},	})}));let buttonStyle = new Style({font: '30px', color: 'white'});let blueSkin = new Skin ({fill: '#3498db'});let redS = new Skin ({fill: '#af5155'});let backButton = Container.template($ => ({  left: 0, right: 0, top: 0, bottom: 0, skin: blueSkin,  active: true,  contents: [    new Label({      left: 0, right:0, top: 0, bottom: 0,      style: buttonStyle,      string: 'Feed Pet'    })  ],  behavior: Behavior({  	onTouchEnded(container, id, x, y, ticks) {	    container.skin = redS;	    remotePins.invoke("/light/write", 1);	}})}));let TOP_BAR = new Line({          left: 0, right: 0, height: 30, skin: graySkin,          contents: [          	new Label({left: 10, right: 10, top: 5,          		style: whiteMedStyle, string: "Historical Analytics"}),          ]      });let DOTS = new Line ({      		width: 640, height: 20, top: 10, skin: rightmenuDots,      });
      let graph_image_skin = new Skin({      width: 620, height: 385,      texture: new Texture("images/graph.PNG"),      //fill: "white",      aspect: "fit"});

let graph_thing = new Line({
		left: 0, right: 0, top: 0, height: 198, skin: graph_image_skin,
});var Scroller = Column.template($ => ({    top: 0, bottom: 55, left: 0, right: 0,     skin: new Skin({fill: "#202020"}),    contents: [        new Column({             top: 0, height: 500, left: 0, right: 0, skin: darkGraySkin,             style: titleStyle,             contents: [                 VerticalScroller($, {                             active: true, top: 0, bottom: 0,                            contents: [                                new $.contentToScrollVertically,                                VerticalScrollbar(),                                 TopScrollerShadow(),                                 BottomScrollerShadow(),                                ]                })            ]        })    ]}));application.behavior = Behavior({	onLaunch: function(content) {        let discoveryInstance = Pins.discover(            connectionDesc => {                if (connectionDesc.name == "/sensor") {                    trace("Connecting to remote pins\n");                    remotePins = Pins.connect(connectionDesc);                }            },             connectionDesc => {               if (connectionDesc.name == "/sensor") {                    trace("Disconnected from remote pins\n");                    remotePins = undefined;               }            }        );		/*		Initializes a GraphContainer, which includes the GraphCanvas,		upon which values are drawn, and the GraphLabel, which displays		the value as text. 		*/		var graph = new GraphContainer();		var graph2 = new GraphContainer();					/**		Parameters for the plotter			name: unique identifier			interval: ms between updates			buckets: number of values displayed on the screen at once			background: background color			strokeStyle: color of the line			lineWidth: width of the line			complement: if true, graph ( 1 - value ) rather than the value 		*/        var plotterParams = {        	name: "sensor1",		     		interval: 10,			buckets:200,        	background: "white",        	strokeStyle: "red",			lineWidth: 4,			complement: true		};		var plotterParams2 = {        	name: "sensor2",		     		interval: 10,			buckets:200,        	background: "white",        	strokeStyle: "red",			lineWidth: 4,			complement: true		};					graph.add( new GraphCanvas1( plotterParams ) );		graph.add( new GraphLabel1( plotterParams) );		graph2.add( new GraphCanvas2( plotterParams2 ) );		graph2.add( new GraphLabel2( plotterParams2) );		let whiteSkin = new Skin({ fill: 'white' });		/* Main screen layout */
let contentToScrollVertically = new Column({ 
    top: 0, left: 0, right: 0, 
    skin: graySkin,
    contents: [
        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Top HR Boosting Songs'    	}),
    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Closer'    	}),
    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Dream On'    	}),
    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Gagnam Style'    	}),
    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Fly'    	}),
    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Baby'    	}),
    	    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'One Time Comin'    	}),
    	    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'No Vasaline'    	}),
    	    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'Lose Yourself'    	}),
    	    	        new Label({	      left: 0, right:0, top: 0,	      style: buttonStyle,	      string: 'All Eyez On Me'    	}),
    	
    ]
});		let CONTENT = Column.template($ => ({   		 	left: 0, right: 0, top: 0, skin: whiteSkin,    		contents: [				//graph,				//graph2,
				graph_thing,
				contentToScrollVertically,				new backButton()			]		}));
    let cont = new Scroller({contentToScrollVertically: CONTENT});		let MainContainer = Column.template($ => ({   		 	left: 0, right: 0, top: 0, bottom: 0, skin: whiteSkin,    		contents: [				TOP_BAR,				cont,				DOTS			]		}));				application.add(new MainContainer());	}})